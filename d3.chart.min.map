{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///d3.chart.min.js","webpack:///webpack/bootstrap 9cd9be93ccbfc17e363c","webpack:///./chart-extensions.js","webpack:///external \"d3\"","webpack:///./chart.js","webpack:///./assert.js","webpack:///./has-own-prop.js","webpack:///./layer-extensions.js","webpack:///./layer.js"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_RESULT__","d3","Chart","assert","test","version","chart","name","arguments","length","extend","apply","selection","prototype","chartName","options","_chart","ChartCtor","enter","transition","undefined","object","argsIndex","argsLength","iteratee","key","hasOwnProp","initCascade","instance","args","ctor","constructor","sup","__super__","initialize","transformCascade","data","transform","chartOptions","base","_layers","_attached","_events","unlayer","layer","draw","attach","attachmentName","layerName","attachmentData","demux","on","callback","context","events","push","once","self","off","names","n","event","j","Object","keys","splice","trigger","ev","Array","slice","protoProps","staticProps","child","parent","Surrogate","message","Error","hasOwnProperty","Layer","eventName","dataBind","insert","lifecycleRe","_base","_handlers","handler","idx","handlers","bound","entering","method","len","exit","l","empty"],"mappings":"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","file":"d3.chart.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3\")) : factory(root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*!\n * d3.chart - v0.2.1\n * License: MIT\n * Date: 2016-00-05\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"d3\")) : factory(root[\"d3\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar d3 = __webpack_require__(1);\n\t\n\tvar Chart = __webpack_require__(2);\n\tvar assert = __webpack_require__(3);\n\t\n\tassert(/^3\\./.test(d3.version), \"d3.js version 3 is required\");\n\t\n\t__webpack_require__(5);\n\t\n\t/**\n\t * A namespace defined by [the D3.js library](http://d3js.org/). The d3.chart\n\t * API is defined within this namespace.\n\t * @namespace d3\n\t */\n\t\n\t/**\n\t * A constructor function defined by [the D3.js library](http://d3js.org/).\n\t * @constructor d3.selection\n\t * @memberof d3\n\t */\n\t\n\t/**\n\t * Create a new chart constructor or return a previously-created chart\n\t * constructor.\n\t *\n\t * @static\n\t * @memberof d3\n\t * @externalExample {runnable} chart\n\t *\n\t * @param {String} name If no other arguments are specified, return the\n\t *        previously-created chart with this name.\n\t * @param {Object} protoProps If specified, this value will be forwarded to\n\t *        {@link Chart.extend} and used to create a new chart.\n\t * @param {Object} staticProps If specified, this value will be forwarded to\n\t *        {@link Chart.extend} and used to create a new chart.\n\t */\n\td3.chart = function(name) {\n\t\tif (arguments.length === 0) {\n\t\t\treturn Chart;\n\t\t} else if (arguments.length === 1) {\n\t\t\treturn Chart[name];\n\t\t}\n\t\n\t\treturn Chart.extend.apply(Chart, arguments);\n\t};\n\t\n\t/**\n\t * Instantiate a chart or return the chart that the current selection belongs\n\t * to.\n\t *\n\t * @externalExample {runnable} selection-chart\n\t *\n\t * @param {String} [chartName] The name of the chart to instantiate. If the\n\t *        name is unspecified, this method will return the chart that the\n\t *        current selection belongs to.\n\t * @param {mixed} options The options to use when instantiated the new chart.\n\t *        See {@link Chart} for more information.\n\t */\n\td3.selection.prototype.chart = function(chartName, options) {\n\t\t// Without an argument, attempt to resolve the current selection's\n\t\t// containing d3.chart.\n\t\tif (arguments.length === 0) {\n\t\t\treturn this._chart;\n\t\t}\n\t\tvar ChartCtor = Chart[chartName];\n\t\tassert(ChartCtor, \"No chart registered with name '\" + chartName + \"'\");\n\t\n\t\treturn new ChartCtor(this, options);\n\t};\n\t\n\t// Implement the zero-argument signature of `d3.selection.prototype.chart`\n\t// for all selection types.\n\td3.selection.enter.prototype.chart = function() {\n\t\treturn this._chart;\n\t};\n\td3.transition.prototype.chart = d3.selection.enter.prototype.chart;\n\t\n\tmodule.exports = d3.chart;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar assert = __webpack_require__(3);\n\tvar hasOwnProp = __webpack_require__(4);\n\t\n\t// extend\n\t// Borrowed from Underscore.js\n\tfunction extend(object) {\n\t\tvar argsIndex, argsLength, iteratee, key;\n\t\tif (!object) {\n\t\t\treturn object;\n\t\t}\n\t\targsLength = arguments.length;\n\t\tfor (argsIndex = 1; argsIndex < argsLength; argsIndex++) {\n\t\t\titeratee = arguments[argsIndex];\n\t\t\tif (iteratee) {\n\t\t\t\tfor (key in iteratee) {\n\t\t\t\t\tobject[key] = iteratee[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn object;\n\t}\n\t\n\t/**\n\t * Call the {@Chart#initialize} method up the inheritance chain, starting with\n\t * the base class and continuing \"downward\".\n\t *\n\t * @private\n\t */\n\tvar initCascade = function(instance, args) {\n\t\tvar ctor = this.constructor;\n\t\tvar sup = ctor.__super__;\n\t\tif (sup) {\n\t\t\tinitCascade.call(sup, instance, args);\n\t\t}\n\t\n\t\t// Do not invoke the `initialize` method on classes further up the\n\t\t// prototype chain (again).\n\t\tif (hasOwnProp.call(ctor.prototype, \"initialize\")) {\n\t\t\tthis.initialize.apply(instance, args);\n\t\t}\n\t};\n\t\n\t/**\n\t * Call the `transform` method down the inheritance chain, starting with the\n\t * instance and continuing \"upward\". The result of each transformation should\n\t * be supplied as input to the next.\n\t *\n\t * @private\n\t */\n\tvar transformCascade = function(instance, data) {\n\t\tvar ctor = this.constructor;\n\t\tvar sup = ctor.__super__;\n\t\n\t\t// Unlike `initialize`, the `transform` method has significance when\n\t\t// attached directly to a chart instance. Ensure that this transform takes\n\t\t// first but is not invoked on later recursions.\n\t\tif (this === instance && hasOwnProp.call(this, \"transform\")) {\n\t\t\tdata = this.transform(data);\n\t\t}\n\t\n\t\t// Do not invoke the `transform` method on classes further up the prototype\n\t\t// chain (yet).\n\t\tif (hasOwnProp.call(ctor.prototype, \"transform\")) {\n\t\t\tdata = ctor.prototype.transform.call(instance, data);\n\t\t}\n\t\n\t\tif (sup) {\n\t\t\tdata = transformCascade.call(sup, instance, data);\n\t\t}\n\t\n\t\treturn data;\n\t};\n\t\n\t/**\n\t * Create a d3.chart\n\t *\n\t * @constructor\n\t * @externalExample {runnable} chart\n\t *\n\t * @param {d3.selection} selection The chart's \"base\" DOM node. This should\n\t *        contain any nodes that the chart generates.\n\t * @param {mixed} chartOptions A value for controlling how the chart should be\n\t *        created. This value will be forwarded to {@link Chart#initialize}, so\n\t *        charts may define additional properties for consumers to modify their\n\t *        behavior during initialization. The following attributes will be\n\t *        copied onto the chart instance (if present):\n\t * @param {Function} [chartOptions.transform] - A data transformation function\n\t *        unique to the Chart instance being created. If specified, this\n\t *        function will be invoked after all inherited implementations as part\n\t *        of the `Chart#draw` operation.\n\t * @param {Function} [chartOptions.demux] - A data filtering function for\n\t *        attachment charts. If specified, this function will be invoked with\n\t *        every {@link Chart#draw|draw} operation and provided with two\n\t *        arguments: the attachment name (see {@link Chart#attach}) and the\n\t *        data.\n\t *\n\t * @constructor\n\t */\n\tvar Chart = function(selection, chartOptions) {\n\t\tthis.base = selection;\n\t\tthis._layers = {};\n\t\tthis._attached = {};\n\t\tthis._events = {};\n\t\n\t\tif (chartOptions && chartOptions.transform) {\n\t\t\tthis.transform = chartOptions.transform;\n\t\t}\n\t\n\t\tinitCascade.call(this, this, [chartOptions]);\n\t};\n\t\n\t/**\n\t * Set up a chart instance. This method is intended to be overridden by Charts\n\t * authored with this library. It will be invoked with a single argument: the\n\t * `options` value supplied to the {@link Chart|constructor}.\n\t *\n\t * For charts that are defined as extensions of other charts using\n\t * `Chart.extend`, each chart's `initilize` method will be invoked starting\n\t * with the \"oldest\" ancestor (see the private {@link initCascade} function for\n\t * more details).\n\t */\n\tChart.prototype.initialize = function() {};\n\t\n\t/**\n\t * Remove a layer from the chart.\n\t *\n\t * @externalExample chart-unlayer\n\t *\n\t * @param {String} name The name of the layer to remove.\n\t *\n\t * @returns {Layer} The layer removed by this operation.\n\t */\n\tChart.prototype.unlayer = function(name) {\n\t\tvar layer = this.layer(name);\n\t\n\t\tdelete this._layers[name];\n\t\tdelete layer._chart;\n\t\n\t\treturn layer;\n\t};\n\t\n\t/**\n\t * Interact with the chart's {@link Layer|layers}.\n\t *\n\t * If only a `name` is provided, simply return the layer registered to that\n\t * name (if any).\n\t *\n\t * If a `name` and `selection` are provided, treat the `selection` as a\n\t * previously-created layer and attach it to the chart with the specified\n\t * `name`.\n\t *\n\t * If all three arguments are specified, initialize a new {@link Layer} using\n\t * the specified `selection` as a base passing along the specified `options`.\n\t *\n\t * The {@link Layer.draw} method of attached layers will be invoked\n\t * whenever this chart's {@link Chart#draw} is invoked and will receive the\n\t * data (optionally modified by the chart's {@link Chart#transform} method.\n\t *\n\t * @externalExample chart-layer\n\t *\n\t * @param {String} name Name of the layer to attach or retrieve.\n\t * @param {d3.selection|Layer} [selection] The layer's base or a\n\t *        previously-created {@link Layer}.\n\t * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t *        constructor}\n\t *\n\t * @returns {Layer}\n\t */\n\tChart.prototype.layer = function(name, selection, options) {\n\t\tvar layer;\n\t\n\t\tif (arguments.length === 1) {\n\t\t\treturn this._layers[name];\n\t\t}\n\t\n\t\t// we are reattaching a previous layer, which the\n\t\t// selection argument is now set to.\n\t\tif (arguments.length === 2) {\n\t\n\t\t\tif (typeof selection.draw === \"function\") {\n\t\t\t\tselection._chart = this;\n\t\t\t\tthis._layers[name] = selection;\n\t\t\t\treturn this._layers[name];\n\t\n\t\t\t} else {\n\t\t\t\tassert(false, \"When reattaching a layer, the second argument \" +\n\t\t\t\t\t\"must be a d3.chart layer\");\n\t\t\t}\n\t\t}\n\t\n\t\tlayer = selection.layer(options);\n\t\n\t\tthis._layers[name] = layer;\n\t\n\t\tselection._chart = this;\n\t\n\t\treturn layer;\n\t};\n\t\n\t/**\n\t * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n\t * method will be invoked whenever the containing chart's `draw` method is\n\t * invoked.\n\t *\n\t * @externalExample chart-attach\n\t *\n\t * @param {String} attachmentName Name of the attachment\n\t * @param {Chart} [chart] d3.chart to register as a mix in of this chart. When\n\t *        unspecified, this method will return the attachment previously\n\t *        registered with the specified `attachmentName` (if any).\n\t *\n\t * @returns {Chart} Reference to this chart (chainable).\n\t */\n\tChart.prototype.attach = function(attachmentName, chart) {\n\t\tif (arguments.length === 1) {\n\t\t\treturn this._attached[attachmentName];\n\t\t}\n\t\n\t\tthis._attached[attachmentName] = chart;\n\t\treturn chart;\n\t};\n\t\n\t/**\n\t * A \"hook\" method that you may define to modify input data before it is used\n\t * to draw the chart's layers and attachments. This method will be used by all\n\t * sub-classes (see {@link transformCascade} for details).\n\t *\n\t * Note you will most likely never call this method directly, but rather\n\t * include it as part of a chart definition, and then rely on d3.chart to\n\t * invoke it when you draw the chart with {@link Chart#draw}.\n\t *\n\t * @externalExample {runnable} chart-transform\n\t *\n\t * @param {Array} data Input data provided to @link Chart#draw}.\n\t *\n\t * @returns {mixed} Data to be used in drawing the chart's layers and\n\t *                  attachments.\n\t */\n\tChart.prototype.transform = function(data) {\n\t\treturn data;\n\t};\n\t\n\t/**\n\t * Update the chart's representation in the DOM, drawing all of its layers and\n\t * any \"attachment\" charts (as attached via {@link Chart#attach}).\n\t *\n\t * @externalExample chart-draw\n\t *\n\t * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n\t *        this cart's {@link Layer|layers} (if any) and the {@link\n\t *        Chart#draw|draw method} of this chart's attachments (if any).\n\t */\n\tChart.prototype.draw = function(data) {\n\t\n\t\tvar layerName, attachmentName, attachmentData;\n\t\n\t\tdata = transformCascade.call(this, this, data);\n\t\n\t\tfor (layerName in this._layers) {\n\t\t\tthis._layers[layerName].draw(data);\n\t\t}\n\t\n\t\tfor (attachmentName in this._attached) {\n\t\t\tif (this.demux) {\n\t\t\t\tattachmentData = this.demux(attachmentName, data);\n\t\t\t} else {\n\t\t\t\tattachmentData = data;\n\t\t\t}\n\t\t\tthis._attached[attachmentName].draw(attachmentData);\n\t\t}\n\t};\n\t\n\t/**\n\t * Function invoked with the context specified when the handler was bound (via\n\t * {@link Chart#on} {@link Chart#once}).\n\t *\n\t * @callback ChartEventHandler\n\t * @param {...*} arguments Invoked with the arguments passed to {@link\n\t *         Chart#trigger}\n\t */\n\t\n\t/**\n\t * Subscribe a callback function to an event triggered on the chart. See {@link\n\t * Chart#once} to subscribe a callback function to an event for one occurence.\n\t *\n\t * @externalExample {runnable} chart-on\n\t *\n\t * @param {String} name Name of the event\n\t * @param {ChartEventHandler} callback Function to be invoked when the event\n\t *        occurs\n\t * @param {Object} [context] Value to set as `this` when invoking the\n\t *        `callback`. Defaults to the chart instance.\n\t *\n\t * @returns {Chart} A reference to this chart (chainable).\n\t */\n\tChart.prototype.on = function(name, callback, context) {\n\t\tvar events = this._events[name] || (this._events[name] = []);\n\t\tevents.push({\n\t\t\tcallback: callback,\n\t\t\tcontext: context || this,\n\t\t\t_chart: this\n\t\t});\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Subscribe a callback function to an event triggered on the chart. This\n\t * function will be invoked at the next occurance of the event and immediately\n\t * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n\t * event indefinitely.\n\t *\n\t * @externalExample {runnable} chart-once\n\t *\n\t * @param {String} name Name of the event\n\t * @param {ChartEventHandler} callback Function to be invoked when the event\n\t *        occurs\n\t * @param {Object} [context] Value to set as `this` when invoking the\n\t *        `callback`. Defaults to the chart instance\n\t *\n\t * @returns {Chart} A reference to this chart (chainable)\n\t */\n\tChart.prototype.once = function(name, callback, context) {\n\t\tvar self = this;\n\t\tvar once = function() {\n\t\t\tself.off(name, once);\n\t\t\tcallback.apply(this, arguments);\n\t\t};\n\t\treturn this.on(name, once, context);\n\t};\n\t\n\t/**\n\t * Unsubscribe one or more callback functions from an event triggered on the\n\t * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n\t * When only a `name` is specified, all handlers subscribed to that event will\n\t * be unsubscribed. When a `name` and `callback` are specified, only that\n\t * function will be unsubscribed from that event. When a `name` and `context`\n\t * are specified (but `callback` is omitted), all events bound to the given\n\t * event with the given context will be unsubscribed.\n\t *\n\t * @externalExample {runnable} chart-off\n\t *\n\t * @param {String} [name] Name of the event to be unsubscribed\n\t * @param {ChartEventHandler} [callback] Function to be unsubscribed\n\t * @param {Object} [context] Contexts to be unsubscribe\n\t *\n\t * @returns {Chart} A reference to this chart (chainable).\n\t */\n\tChart.prototype.off = function(name, callback, context) {\n\t\tvar names, n, events, event, i, j;\n\t\n\t\t// remove all events\n\t\tif (arguments.length === 0) {\n\t\t\tfor (name in this._events) {\n\t\t\t\tthis._events[name].length = 0;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\n\t\t// remove all events for a specific name\n\t\tif (arguments.length === 1) {\n\t\t\tevents = this._events[name];\n\t\t\tif (events) {\n\t\t\t\tevents.length = 0;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\n\t\t// remove all events that match whatever combination of name, context\n\t\t// and callback.\n\t\tnames = name ? [name] : Object.keys(this._events);\n\t\tfor (i = 0; i < names.length; i++) {\n\t\t\tn = names[i];\n\t\t\tevents = this._events[n];\n\t\t\tj = events.length;\n\t\t\twhile (j--) {\n\t\t\t\tevent = events[j];\n\t\t\t\tif ((callback && callback === event.callback) ||\n\t\t\t\t\t\t(context && context === event.context)) {\n\t\t\t\t\tevents.splice(j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Publish an event on this chart with the given `name`.\n\t *\n\t * @externalExample {runnable} chart-trigger\n\t *\n\t * @param {String} name Name of the event to publish\n\t * @param {...*} arguments Values with which to invoke the registered\n\t *        callbacks.\n\t *\n\t * @returns {Chart} A reference to this chart (chainable).\n\t */\n\tChart.prototype.trigger = function(name) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\tvar events = this._events[name];\n\t\tvar i, ev;\n\t\n\t\tif (events !== undefined) {\n\t\t\tfor (i = 0; i < events.length; i++) {\n\t\t\t\tev = events[i];\n\t\t\t\tev.callback.apply(ev.context, args);\n\t\t\t}\n\t\t}\n\t\n\t\treturn this;\n\t};\n\t\n\t/**\n\t * Create a new {@link Chart} constructor with the provided options acting as\n\t * \"overrides\" for the default chart instance methods. Allows for basic\n\t * inheritance so that new chart constructors may be defined in terms of\n\t * existing chart constructors. Based on the `extend` function defined by\n\t * [Backbone.js](http://backbonejs.org/).\n\t *\n\t * @static\n\t * @externalExample {runnable} chart-extend\n\t *\n\t * @param {String} name Identifier for the new Chart constructor.\n\t * @param {Object} protoProps Properties to set on the new chart's prototype.\n\t * @param {Object} staticProps Properties to set on the chart constructor\n\t *        itself.\n\t *\n\t * @returns {Function} A new Chart constructor\n\t */\n\tChart.extend = function(name, protoProps, staticProps) {\n\t\tvar parent = this;\n\t\tvar child;\n\t\n\t\t// The constructor function for the new subclass is either defined by\n\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t// defaulted by us to simply call the parent's constructor.\n\t\tif (protoProps && hasOwnProp.call(protoProps, \"constructor\")) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function(){ return parent.apply(this, arguments); };\n\t\t}\n\t\n\t\t// Add static properties to the constructor function, if supplied.\n\t\textend(child, parent, staticProps);\n\t\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tvar Surrogate = function(){ this.constructor = child; };\n\t\tSurrogate.prototype = parent.prototype;\n\t\tchild.prototype = new Surrogate();\n\t\n\t\t// Add prototype properties (instance properties) to the subclass, if\n\t\t// supplied.\n\t\tif (protoProps) { extend(child.prototype, protoProps); }\n\t\n\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t// later.\n\t\tchild.__super__ = parent.prototype;\n\t\n\t\tChart[name] = child;\n\t\treturn child;\n\t};\n\t\n\tmodule.exports = Chart;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\t\n\tmodule.exports = function(test, message) {\n\t\tif (test) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(\"[d3.chart] \" + message);\n\t};\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\t\"use strict\";\n\t\tmodule.exports = Object.hasOwnProperty;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require) {\n\t\"use strict\";\n\tvar d3 = __webpack_require__(1);\n\t\n\tvar Layer = __webpack_require__(6);\n\t\n\t/**\n\t * Create a new layer on the d3 selection from which it is called.\n\t *\n\t * @static\n\t *\n\t * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n\t *        constructor}\n\t * @returns {d3.selection}\n\t */\n\td3.selection.prototype.layer = function(options) {\n\t\tvar layer = new Layer(this);\n\t\tvar eventName;\n\t\n\t\t// Set layer methods (required)\n\t\tlayer.dataBind = options.dataBind;\n\t\tlayer.insert = options.insert;\n\t\n\t\t// Bind events (optional)\n\t\tif (\"events\" in options) {\n\t\t\tfor (eventName in options.events) {\n\t\t\t\tlayer.on(eventName, options.events[eventName]);\n\t\t\t}\n\t\t}\n\t\n\t\t// Mix the public methods into the D3.js selection (bound appropriately)\n\t\tthis.on = function() { return layer.on.apply(layer, arguments); };\n\t\tthis.off = function() { return layer.off.apply(layer, arguments); };\n\t\tthis.draw = function() { return layer.draw.apply(layer, arguments); };\n\t\n\t\treturn this;\n\t};\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar d3 = __webpack_require__(1);\n\t\n\tvar assert = __webpack_require__(3);\n\t\n\tvar lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\t\n\t/**\n\t * Create a layer using the provided `base`. The layer instance is *not*\n\t * exposed to d3.chart users. Instead, its instance methods are mixed in to the\n\t * `base` selection it describes; users interact with the instance via these\n\t * bound methods.\n\t *\n\t * @private\n\t * @constructor\n\t * @externalExample {runnable} layer\n\t *\n\t * @param {d3.selection} base The containing DOM node for the layer.\n\t */\n\tvar Layer = function(base) {\n\t\tassert(base, \"Layers must be initialized with a base.\");\n\t\tthis._base = base;\n\t\tthis._handlers = {};\n\t};\n\t\n\t/**\n\t * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n\t * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n\t *\n\t * @param {Array} data Value passed to {@link Layer#draw}\n\t */\n\tLayer.prototype.dataBind = function() {\n\t\tassert(false, \"Layers must specify a `dataBind` method.\");\n\t};\n\t\n\t/**\n\t * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n\t * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n\t * Layer instances.\n\t */\n\tLayer.prototype.insert = function() {\n\t\tassert(false, \"Layers must specify an `insert` method.\");\n\t};\n\t\n\t/**\n\t * Subscribe a handler to a \"lifecycle event\". These events (and only these\n\t * events) are triggered when {@link Layer#draw} is invoked--see that method\n\t * for more details on lifecycle events.\n\t *\n\t * @externalExample {runnable} layer-on\n\t *\n\t * @param {String} eventName Identifier for the lifecycle event for which to\n\t *        subscribe.\n\t * @param {Function} handler Callback function\n\t *\n\t * @returns {d3.selection} Reference to the layer's base.\n\t */\n\tLayer.prototype.on = function(eventName, handler, options) {\n\t\toptions = options || {};\n\t\n\t\tassert(\n\t\t\tlifecycleRe.test(eventName),\n\t\t\t\"Unrecognized lifecycle event name specified to `Layer#on`: '\" +\n\t\t\teventName + \"'.\"\n\t\t);\n\t\n\t\tif (!(eventName in this._handlers)) {\n\t\t\tthis._handlers[eventName] = [];\n\t\t}\n\t\tthis._handlers[eventName].push({\n\t\t\tcallback: handler,\n\t\t\tchart: options.chart || null\n\t\t});\n\t\treturn this._base;\n\t};\n\t\n\t/**\n\t * Unsubscribe the specified handler from the specified event. If no handler is\n\t * supplied, remove *all* handlers from the event.\n\t *\n\t * @externalExample {runnable} layer-off\n\t *\n\t * @param {String} eventName Identifier for event from which to remove\n\t *        unsubscribe\n\t * @param {Function} handler Callback to remove from the specified event\n\t *\n\t * @returns {d3.selection} Reference to the layer's base.\n\t */\n\tLayer.prototype.off = function(eventName, handler) {\n\t\n\t\tvar handlers = this._handlers[eventName];\n\t\tvar idx;\n\t\n\t\tassert(\n\t\t\tlifecycleRe.test(eventName),\n\t\t\t\"Unrecognized lifecycle event name specified to `Layer#off`: '\" +\n\t\t\teventName + \"'.\"\n\t\t);\n\t\n\t\tif (!handlers) {\n\t\t\treturn this._base;\n\t\t}\n\t\n\t\tif (arguments.length === 1) {\n\t\t\thandlers.length = 0;\n\t\t\treturn this._base;\n\t\t}\n\t\n\t\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\t\tif (handlers[idx].callback === handler) {\n\t\t\t\thandlers.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t\treturn this._base;\n\t};\n\t\n\t/**\n\t * Render the layer according to the input data: Bind the data to the layer\n\t * (according to {@link Layer#dataBind}, insert new elements (according to\n\t * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n\t * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n\t *\n\t * - update\n\t * - update:transition\n\t * - enter\n\t * - enter:transition\n\t * - exit\n\t * - exit:transition\n\t *\n\t * @externalExample {runnable} layer-draw\n\t *\n\t * @param {Array} data Data to drive the rendering.\n\t */\n\tLayer.prototype.draw = function(data) {\n\t\tvar bound, entering, events, selection, method, handlers, eventName, idx,\n\t\t\tlen;\n\t\n\t\tbound = this.dataBind.call(this._base, data);\n\t\n\t\t// Although `bound instanceof d3.selection` is more explicit, it fails\n\t\t// in IE8, so we use duck typing to maintain compatability.\n\t\tassert(bound && bound.call === d3.selection.prototype.call,\n\t\t\t\"Invalid selection defined by `Layer#dataBind` method.\");\n\t\tassert(bound.enter, \"Layer selection not properly bound.\");\n\t\n\t\tentering = bound.enter();\n\t\tentering._chart = this._base._chart;\n\t\n\t\tevents = [\n\t\t\t{\n\t\t\t\tname: \"update\",\n\t\t\t\tselection: bound\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"enter\",\n\t\t\t\tselection: entering,\n\t\t\t\tmethod: this.insert\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"merge\",\n\t\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t\t// when triggering the `enter` event.\n\t\t\t\tselection: bound\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"exit\",\n\t\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t\t// `d3.selection.exit`.\n\t\t\t\tselection: bound,\n\t\t\t\tmethod: bound.exit\n\t\t\t}\n\t\t];\n\t\n\t\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\t\teventName = events[i].name;\n\t\t\tselection = events[i].selection;\n\t\t\tmethod = events[i].method;\n\t\n\t\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t\t// deferred until just prior to handler invocation.\n\t\t\tif (typeof method === \"function\") {\n\t\t\t\tselection = method.call(selection);\n\t\t\t}\n\t\n\t\t\tif (selection.empty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t\t// compatability.\n\t\t\tassert(selection &&\n\t\t\t\tselection.call === d3.selection.prototype.call,\n\t\t\t\t\"Invalid selection defined for '\" + eventName +\n\t\t\t\t\"' lifecycle event.\");\n\t\n\t\t\thandlers = this._handlers[eventName];\n\t\n\t\t\tif (handlers) {\n\t\t\t\tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t\t\t\t\t// Attach a reference to the parent chart so the selection\"s\n\t\t\t\t\t// `chart` method will function correctly.\n\t\t\t\t\tselection._chart = handlers[idx].chart || this._base._chart;\n\t\t\t\t\tselection.call(handlers[idx].callback);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\thandlers = this._handlers[eventName + \":transition\"];\n\t\n\t\t\tif (handlers && handlers.length) {\n\t\t\t\tselection = selection.transition();\n\t\t\t\tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t\t\t\t\tselection._chart = handlers[idx].chart || this._base._chart;\n\t\t\t\t\tselection.call(handlers[idx].callback);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tmodule.exports = Layer;\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** d3.chart.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9cd9be93ccbfc17e363c\n **/","define(function(require, exports, module) {\n\"use strict\";\nvar d3 = require(\"d3\");\n\nvar Chart = require(\"./chart\");\nvar assert = require(\"./assert\");\n\nassert(/^3\\./.test(d3.version), \"d3.js version 3 is required\");\n\nrequire(\"./layer-extensions\");\n\n/**\n * A namespace defined by [the D3.js library](http://d3js.org/). The d3.chart\n * API is defined within this namespace.\n * @namespace d3\n */\n\n/**\n * A constructor function defined by [the D3.js library](http://d3js.org/).\n * @constructor d3.selection\n * @memberof d3\n */\n\n/**\n * Create a new chart constructor or return a previously-created chart\n * constructor.\n *\n * @static\n * @memberof d3\n * @externalExample {runnable} chart\n *\n * @param {String} name If no other arguments are specified, return the\n *        previously-created chart with this name.\n * @param {Object} protoProps If specified, this value will be forwarded to\n *        {@link Chart.extend} and used to create a new chart.\n * @param {Object} staticProps If specified, this value will be forwarded to\n *        {@link Chart.extend} and used to create a new chart.\n */\nd3.chart = function(name) {\n\tif (arguments.length === 0) {\n\t\treturn Chart;\n\t} else if (arguments.length === 1) {\n\t\treturn Chart[name];\n\t}\n\n\treturn Chart.extend.apply(Chart, arguments);\n};\n\n/**\n * Instantiate a chart or return the chart that the current selection belongs\n * to.\n *\n * @externalExample {runnable} selection-chart\n *\n * @param {String} [chartName] The name of the chart to instantiate. If the\n *        name is unspecified, this method will return the chart that the\n *        current selection belongs to.\n * @param {mixed} options The options to use when instantiated the new chart.\n *        See {@link Chart} for more information.\n */\nd3.selection.prototype.chart = function(chartName, options) {\n\t// Without an argument, attempt to resolve the current selection's\n\t// containing d3.chart.\n\tif (arguments.length === 0) {\n\t\treturn this._chart;\n\t}\n\tvar ChartCtor = Chart[chartName];\n\tassert(ChartCtor, \"No chart registered with name '\" + chartName + \"'\");\n\n\treturn new ChartCtor(this, options);\n};\n\n// Implement the zero-argument signature of `d3.selection.prototype.chart`\n// for all selection types.\nd3.selection.enter.prototype.chart = function() {\n\treturn this._chart;\n};\nd3.transition.prototype.chart = d3.selection.enter.prototype.chart;\n\nmodule.exports = d3.chart;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./chart-extensions.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"d3\"\n ** module id = 1\n ** module chunks = 0\n **/","define(function(require, exports, module) {\n\"use strict\";\nvar assert = require(\"./assert\");\nvar hasOwnProp = require(\"./has-own-prop\");\n\n// extend\n// Borrowed from Underscore.js\nfunction extend(object) {\n\tvar argsIndex, argsLength, iteratee, key;\n\tif (!object) {\n\t\treturn object;\n\t}\n\targsLength = arguments.length;\n\tfor (argsIndex = 1; argsIndex < argsLength; argsIndex++) {\n\t\titeratee = arguments[argsIndex];\n\t\tif (iteratee) {\n\t\t\tfor (key in iteratee) {\n\t\t\t\tobject[key] = iteratee[key];\n\t\t\t}\n\t\t}\n\t}\n\treturn object;\n}\n\n/**\n * Call the {@Chart#initialize} method up the inheritance chain, starting with\n * the base class and continuing \"downward\".\n *\n * @private\n */\nvar initCascade = function(instance, args) {\n\tvar ctor = this.constructor;\n\tvar sup = ctor.__super__;\n\tif (sup) {\n\t\tinitCascade.call(sup, instance, args);\n\t}\n\n\t// Do not invoke the `initialize` method on classes further up the\n\t// prototype chain (again).\n\tif (hasOwnProp.call(ctor.prototype, \"initialize\")) {\n\t\tthis.initialize.apply(instance, args);\n\t}\n};\n\n/**\n * Call the `transform` method down the inheritance chain, starting with the\n * instance and continuing \"upward\". The result of each transformation should\n * be supplied as input to the next.\n *\n * @private\n */\nvar transformCascade = function(instance, data) {\n\tvar ctor = this.constructor;\n\tvar sup = ctor.__super__;\n\n\t// Unlike `initialize`, the `transform` method has significance when\n\t// attached directly to a chart instance. Ensure that this transform takes\n\t// first but is not invoked on later recursions.\n\tif (this === instance && hasOwnProp.call(this, \"transform\")) {\n\t\tdata = this.transform(data);\n\t}\n\n\t// Do not invoke the `transform` method on classes further up the prototype\n\t// chain (yet).\n\tif (hasOwnProp.call(ctor.prototype, \"transform\")) {\n\t\tdata = ctor.prototype.transform.call(instance, data);\n\t}\n\n\tif (sup) {\n\t\tdata = transformCascade.call(sup, instance, data);\n\t}\n\n\treturn data;\n};\n\n/**\n * Create a d3.chart\n *\n * @constructor\n * @externalExample {runnable} chart\n *\n * @param {d3.selection} selection The chart's \"base\" DOM node. This should\n *        contain any nodes that the chart generates.\n * @param {mixed} chartOptions A value for controlling how the chart should be\n *        created. This value will be forwarded to {@link Chart#initialize}, so\n *        charts may define additional properties for consumers to modify their\n *        behavior during initialization. The following attributes will be\n *        copied onto the chart instance (if present):\n * @param {Function} [chartOptions.transform] - A data transformation function\n *        unique to the Chart instance being created. If specified, this\n *        function will be invoked after all inherited implementations as part\n *        of the `Chart#draw` operation.\n * @param {Function} [chartOptions.demux] - A data filtering function for\n *        attachment charts. If specified, this function will be invoked with\n *        every {@link Chart#draw|draw} operation and provided with two\n *        arguments: the attachment name (see {@link Chart#attach}) and the\n *        data.\n *\n * @constructor\n */\nvar Chart = function(selection, chartOptions) {\n\tthis.base = selection;\n\tthis._layers = {};\n\tthis._attached = {};\n\tthis._events = {};\n\n\tif (chartOptions && chartOptions.transform) {\n\t\tthis.transform = chartOptions.transform;\n\t}\n\n\tinitCascade.call(this, this, [chartOptions]);\n};\n\n/**\n * Set up a chart instance. This method is intended to be overridden by Charts\n * authored with this library. It will be invoked with a single argument: the\n * `options` value supplied to the {@link Chart|constructor}.\n *\n * For charts that are defined as extensions of other charts using\n * `Chart.extend`, each chart's `initilize` method will be invoked starting\n * with the \"oldest\" ancestor (see the private {@link initCascade} function for\n * more details).\n */\nChart.prototype.initialize = function() {};\n\n/**\n * Remove a layer from the chart.\n *\n * @externalExample chart-unlayer\n *\n * @param {String} name The name of the layer to remove.\n *\n * @returns {Layer} The layer removed by this operation.\n */\nChart.prototype.unlayer = function(name) {\n\tvar layer = this.layer(name);\n\n\tdelete this._layers[name];\n\tdelete layer._chart;\n\n\treturn layer;\n};\n\n/**\n * Interact with the chart's {@link Layer|layers}.\n *\n * If only a `name` is provided, simply return the layer registered to that\n * name (if any).\n *\n * If a `name` and `selection` are provided, treat the `selection` as a\n * previously-created layer and attach it to the chart with the specified\n * `name`.\n *\n * If all three arguments are specified, initialize a new {@link Layer} using\n * the specified `selection` as a base passing along the specified `options`.\n *\n * The {@link Layer.draw} method of attached layers will be invoked\n * whenever this chart's {@link Chart#draw} is invoked and will receive the\n * data (optionally modified by the chart's {@link Chart#transform} method.\n *\n * @externalExample chart-layer\n *\n * @param {String} name Name of the layer to attach or retrieve.\n * @param {d3.selection|Layer} [selection] The layer's base or a\n *        previously-created {@link Layer}.\n * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n *        constructor}\n *\n * @returns {Layer}\n */\nChart.prototype.layer = function(name, selection, options) {\n\tvar layer;\n\n\tif (arguments.length === 1) {\n\t\treturn this._layers[name];\n\t}\n\n\t// we are reattaching a previous layer, which the\n\t// selection argument is now set to.\n\tif (arguments.length === 2) {\n\n\t\tif (typeof selection.draw === \"function\") {\n\t\t\tselection._chart = this;\n\t\t\tthis._layers[name] = selection;\n\t\t\treturn this._layers[name];\n\n\t\t} else {\n\t\t\tassert(false, \"When reattaching a layer, the second argument \" +\n\t\t\t\t\"must be a d3.chart layer\");\n\t\t}\n\t}\n\n\tlayer = selection.layer(options);\n\n\tthis._layers[name] = layer;\n\n\tselection._chart = this;\n\n\treturn layer;\n};\n\n/**\n * Register or retrieve an \"attachment\" Chart. The \"attachment\" chart's `draw`\n * method will be invoked whenever the containing chart's `draw` method is\n * invoked.\n *\n * @externalExample chart-attach\n *\n * @param {String} attachmentName Name of the attachment\n * @param {Chart} [chart] d3.chart to register as a mix in of this chart. When\n *        unspecified, this method will return the attachment previously\n *        registered with the specified `attachmentName` (if any).\n *\n * @returns {Chart} Reference to this chart (chainable).\n */\nChart.prototype.attach = function(attachmentName, chart) {\n\tif (arguments.length === 1) {\n\t\treturn this._attached[attachmentName];\n\t}\n\n\tthis._attached[attachmentName] = chart;\n\treturn chart;\n};\n\n/**\n * A \"hook\" method that you may define to modify input data before it is used\n * to draw the chart's layers and attachments. This method will be used by all\n * sub-classes (see {@link transformCascade} for details).\n *\n * Note you will most likely never call this method directly, but rather\n * include it as part of a chart definition, and then rely on d3.chart to\n * invoke it when you draw the chart with {@link Chart#draw}.\n *\n * @externalExample {runnable} chart-transform\n *\n * @param {Array} data Input data provided to @link Chart#draw}.\n *\n * @returns {mixed} Data to be used in drawing the chart's layers and\n *                  attachments.\n */\nChart.prototype.transform = function(data) {\n\treturn data;\n};\n\n/**\n * Update the chart's representation in the DOM, drawing all of its layers and\n * any \"attachment\" charts (as attached via {@link Chart#attach}).\n *\n * @externalExample chart-draw\n *\n * @param {Object} data Data to pass to the {@link Layer#draw|draw method} of\n *        this cart's {@link Layer|layers} (if any) and the {@link\n *        Chart#draw|draw method} of this chart's attachments (if any).\n */\nChart.prototype.draw = function(data) {\n\n\tvar layerName, attachmentName, attachmentData;\n\n\tdata = transformCascade.call(this, this, data);\n\n\tfor (layerName in this._layers) {\n\t\tthis._layers[layerName].draw(data);\n\t}\n\n\tfor (attachmentName in this._attached) {\n\t\tif (this.demux) {\n\t\t\tattachmentData = this.demux(attachmentName, data);\n\t\t} else {\n\t\t\tattachmentData = data;\n\t\t}\n\t\tthis._attached[attachmentName].draw(attachmentData);\n\t}\n};\n\n/**\n * Function invoked with the context specified when the handler was bound (via\n * {@link Chart#on} {@link Chart#once}).\n *\n * @callback ChartEventHandler\n * @param {...*} arguments Invoked with the arguments passed to {@link\n *         Chart#trigger}\n */\n\n/**\n * Subscribe a callback function to an event triggered on the chart. See {@link\n * Chart#once} to subscribe a callback function to an event for one occurence.\n *\n * @externalExample {runnable} chart-on\n *\n * @param {String} name Name of the event\n * @param {ChartEventHandler} callback Function to be invoked when the event\n *        occurs\n * @param {Object} [context] Value to set as `this` when invoking the\n *        `callback`. Defaults to the chart instance.\n *\n * @returns {Chart} A reference to this chart (chainable).\n */\nChart.prototype.on = function(name, callback, context) {\n\tvar events = this._events[name] || (this._events[name] = []);\n\tevents.push({\n\t\tcallback: callback,\n\t\tcontext: context || this,\n\t\t_chart: this\n\t});\n\treturn this;\n};\n\n/**\n * Subscribe a callback function to an event triggered on the chart. This\n * function will be invoked at the next occurance of the event and immediately\n * unsubscribed. See {@link Chart#on} to subscribe a callback function to an\n * event indefinitely.\n *\n * @externalExample {runnable} chart-once\n *\n * @param {String} name Name of the event\n * @param {ChartEventHandler} callback Function to be invoked when the event\n *        occurs\n * @param {Object} [context] Value to set as `this` when invoking the\n *        `callback`. Defaults to the chart instance\n *\n * @returns {Chart} A reference to this chart (chainable)\n */\nChart.prototype.once = function(name, callback, context) {\n\tvar self = this;\n\tvar once = function() {\n\t\tself.off(name, once);\n\t\tcallback.apply(this, arguments);\n\t};\n\treturn this.on(name, once, context);\n};\n\n/**\n * Unsubscribe one or more callback functions from an event triggered on the\n * chart. When no arguments are specified, *all* handlers will be unsubscribed.\n * When only a `name` is specified, all handlers subscribed to that event will\n * be unsubscribed. When a `name` and `callback` are specified, only that\n * function will be unsubscribed from that event. When a `name` and `context`\n * are specified (but `callback` is omitted), all events bound to the given\n * event with the given context will be unsubscribed.\n *\n * @externalExample {runnable} chart-off\n *\n * @param {String} [name] Name of the event to be unsubscribed\n * @param {ChartEventHandler} [callback] Function to be unsubscribed\n * @param {Object} [context] Contexts to be unsubscribe\n *\n * @returns {Chart} A reference to this chart (chainable).\n */\nChart.prototype.off = function(name, callback, context) {\n\tvar names, n, events, event, i, j;\n\n\t// remove all events\n\tif (arguments.length === 0) {\n\t\tfor (name in this._events) {\n\t\t\tthis._events[name].length = 0;\n\t\t}\n\t\treturn this;\n\t}\n\n\t// remove all events for a specific name\n\tif (arguments.length === 1) {\n\t\tevents = this._events[name];\n\t\tif (events) {\n\t\t\tevents.length = 0;\n\t\t}\n\t\treturn this;\n\t}\n\n\t// remove all events that match whatever combination of name, context\n\t// and callback.\n\tnames = name ? [name] : Object.keys(this._events);\n\tfor (i = 0; i < names.length; i++) {\n\t\tn = names[i];\n\t\tevents = this._events[n];\n\t\tj = events.length;\n\t\twhile (j--) {\n\t\t\tevent = events[j];\n\t\t\tif ((callback && callback === event.callback) ||\n\t\t\t\t\t(context && context === event.context)) {\n\t\t\t\tevents.splice(j, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n};\n\n/**\n * Publish an event on this chart with the given `name`.\n *\n * @externalExample {runnable} chart-trigger\n *\n * @param {String} name Name of the event to publish\n * @param {...*} arguments Values with which to invoke the registered\n *        callbacks.\n *\n * @returns {Chart} A reference to this chart (chainable).\n */\nChart.prototype.trigger = function(name) {\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\tvar events = this._events[name];\n\tvar i, ev;\n\n\tif (events !== undefined) {\n\t\tfor (i = 0; i < events.length; i++) {\n\t\t\tev = events[i];\n\t\t\tev.callback.apply(ev.context, args);\n\t\t}\n\t}\n\n\treturn this;\n};\n\n/**\n * Create a new {@link Chart} constructor with the provided options acting as\n * \"overrides\" for the default chart instance methods. Allows for basic\n * inheritance so that new chart constructors may be defined in terms of\n * existing chart constructors. Based on the `extend` function defined by\n * [Backbone.js](http://backbonejs.org/).\n *\n * @static\n * @externalExample {runnable} chart-extend\n *\n * @param {String} name Identifier for the new Chart constructor.\n * @param {Object} protoProps Properties to set on the new chart's prototype.\n * @param {Object} staticProps Properties to set on the chart constructor\n *        itself.\n *\n * @returns {Function} A new Chart constructor\n */\nChart.extend = function(name, protoProps, staticProps) {\n\tvar parent = this;\n\tvar child;\n\n\t// The constructor function for the new subclass is either defined by\n\t// you (the \"constructor\" property in your `extend` definition), or\n\t// defaulted by us to simply call the parent's constructor.\n\tif (protoProps && hasOwnProp.call(protoProps, \"constructor\")) {\n\t\tchild = protoProps.constructor;\n\t} else {\n\t\tchild = function(){ return parent.apply(this, arguments); };\n\t}\n\n\t// Add static properties to the constructor function, if supplied.\n\textend(child, parent, staticProps);\n\n\t// Set the prototype chain to inherit from `parent`, without calling\n\t// `parent`'s constructor function.\n\tvar Surrogate = function(){ this.constructor = child; };\n\tSurrogate.prototype = parent.prototype;\n\tchild.prototype = new Surrogate();\n\n\t// Add prototype properties (instance properties) to the subclass, if\n\t// supplied.\n\tif (protoProps) { extend(child.prototype, protoProps); }\n\n\t// Set a convenience property in case the parent's prototype is needed\n\t// later.\n\tchild.__super__ = parent.prototype;\n\n\tChart[name] = child;\n\treturn child;\n};\n\nmodule.exports = Chart;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./chart.js\n ** module id = 2\n ** module chunks = 0\n **/","define(function(require, exports, module) {\n\"use strict\";\n\nmodule.exports = function(test, message) {\n\tif (test) {\n\t\treturn;\n\t}\n\tthrow new Error(\"[d3.chart] \" + message);\n};\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./assert.js\n ** module id = 3\n ** module chunks = 0\n **/","define(function(require, exports, module) {\n\t\"use strict\";\n\tmodule.exports = Object.hasOwnProperty;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./has-own-prop.js\n ** module id = 4\n ** module chunks = 0\n **/","define(function(require) {\n\"use strict\";\nvar d3 = require(\"d3\");\n\nvar Layer = require(\"./layer\");\n\n/**\n * Create a new layer on the d3 selection from which it is called.\n *\n * @static\n *\n * @param {Object} [options] Options to be forwarded to {@link Layer|the Layer\n *        constructor}\n * @returns {d3.selection}\n */\nd3.selection.prototype.layer = function(options) {\n\tvar layer = new Layer(this);\n\tvar eventName;\n\n\t// Set layer methods (required)\n\tlayer.dataBind = options.dataBind;\n\tlayer.insert = options.insert;\n\n\t// Bind events (optional)\n\tif (\"events\" in options) {\n\t\tfor (eventName in options.events) {\n\t\t\tlayer.on(eventName, options.events[eventName]);\n\t\t}\n\t}\n\n\t// Mix the public methods into the D3.js selection (bound appropriately)\n\tthis.on = function() { return layer.on.apply(layer, arguments); };\n\tthis.off = function() { return layer.off.apply(layer, arguments); };\n\tthis.draw = function() { return layer.draw.apply(layer, arguments); };\n\n\treturn this;\n};\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./layer-extensions.js\n ** module id = 5\n ** module chunks = 0\n **/","define(function(require, exports, module) {\n\"use strict\";\nvar d3 = require(\"d3\");\n\nvar assert = require(\"./assert\");\n\nvar lifecycleRe = /^(enter|update|merge|exit)(:transition)?$/;\n\n/**\n * Create a layer using the provided `base`. The layer instance is *not*\n * exposed to d3.chart users. Instead, its instance methods are mixed in to the\n * `base` selection it describes; users interact with the instance via these\n * bound methods.\n *\n * @private\n * @constructor\n * @externalExample {runnable} layer\n *\n * @param {d3.selection} base The containing DOM node for the layer.\n */\nvar Layer = function(base) {\n\tassert(base, \"Layers must be initialized with a base.\");\n\tthis._base = base;\n\tthis._handlers = {};\n};\n\n/**\n * Invoked by {@link Layer#draw} to join data with this layer's DOM nodes. This\n * implementation is \"virtual\"--it *must* be overridden by Layer instances.\n *\n * @param {Array} data Value passed to {@link Layer#draw}\n */\nLayer.prototype.dataBind = function() {\n\tassert(false, \"Layers must specify a `dataBind` method.\");\n};\n\n/**\n * Invoked by {@link Layer#draw} in order to insert new DOM nodes into this\n * layer's `base`. This implementation is \"virtual\"--it *must* be overridden by\n * Layer instances.\n */\nLayer.prototype.insert = function() {\n\tassert(false, \"Layers must specify an `insert` method.\");\n};\n\n/**\n * Subscribe a handler to a \"lifecycle event\". These events (and only these\n * events) are triggered when {@link Layer#draw} is invoked--see that method\n * for more details on lifecycle events.\n *\n * @externalExample {runnable} layer-on\n *\n * @param {String} eventName Identifier for the lifecycle event for which to\n *        subscribe.\n * @param {Function} handler Callback function\n *\n * @returns {d3.selection} Reference to the layer's base.\n */\nLayer.prototype.on = function(eventName, handler, options) {\n\toptions = options || {};\n\n\tassert(\n\t\tlifecycleRe.test(eventName),\n\t\t\"Unrecognized lifecycle event name specified to `Layer#on`: '\" +\n\t\teventName + \"'.\"\n\t);\n\n\tif (!(eventName in this._handlers)) {\n\t\tthis._handlers[eventName] = [];\n\t}\n\tthis._handlers[eventName].push({\n\t\tcallback: handler,\n\t\tchart: options.chart || null\n\t});\n\treturn this._base;\n};\n\n/**\n * Unsubscribe the specified handler from the specified event. If no handler is\n * supplied, remove *all* handlers from the event.\n *\n * @externalExample {runnable} layer-off\n *\n * @param {String} eventName Identifier for event from which to remove\n *        unsubscribe\n * @param {Function} handler Callback to remove from the specified event\n *\n * @returns {d3.selection} Reference to the layer's base.\n */\nLayer.prototype.off = function(eventName, handler) {\n\n\tvar handlers = this._handlers[eventName];\n\tvar idx;\n\n\tassert(\n\t\tlifecycleRe.test(eventName),\n\t\t\"Unrecognized lifecycle event name specified to `Layer#off`: '\" +\n\t\teventName + \"'.\"\n\t);\n\n\tif (!handlers) {\n\t\treturn this._base;\n\t}\n\n\tif (arguments.length === 1) {\n\t\thandlers.length = 0;\n\t\treturn this._base;\n\t}\n\n\tfor (idx = handlers.length - 1; idx > -1; --idx) {\n\t\tif (handlers[idx].callback === handler) {\n\t\t\thandlers.splice(idx, 1);\n\t\t}\n\t}\n\treturn this._base;\n};\n\n/**\n * Render the layer according to the input data: Bind the data to the layer\n * (according to {@link Layer#dataBind}, insert new elements (according to\n * {@link Layer#insert}, make lifecycle selections, and invoke all relevant\n * handlers (as attached via {@link Layer#on}) with the lifecycle selections.\n *\n * - update\n * - update:transition\n * - enter\n * - enter:transition\n * - exit\n * - exit:transition\n *\n * @externalExample {runnable} layer-draw\n *\n * @param {Array} data Data to drive the rendering.\n */\nLayer.prototype.draw = function(data) {\n\tvar bound, entering, events, selection, method, handlers, eventName, idx,\n\t\tlen;\n\n\tbound = this.dataBind.call(this._base, data);\n\n\t// Although `bound instanceof d3.selection` is more explicit, it fails\n\t// in IE8, so we use duck typing to maintain compatability.\n\tassert(bound && bound.call === d3.selection.prototype.call,\n\t\t\"Invalid selection defined by `Layer#dataBind` method.\");\n\tassert(bound.enter, \"Layer selection not properly bound.\");\n\n\tentering = bound.enter();\n\tentering._chart = this._base._chart;\n\n\tevents = [\n\t\t{\n\t\t\tname: \"update\",\n\t\t\tselection: bound\n\t\t},\n\t\t{\n\t\t\tname: \"enter\",\n\t\t\tselection: entering,\n\t\t\tmethod: this.insert\n\t\t},\n\t\t{\n\t\t\tname: \"merge\",\n\t\t\t// Although the `merge` lifecycle event shares its selection object\n\t\t\t// with the `update` lifecycle event, the object's contents will be\n\t\t\t// modified when d3.chart invokes the user-supplied `insert` method\n\t\t\t// when triggering the `enter` event.\n\t\t\tselection: bound\n\t\t},\n\t\t{\n\t\t\tname: \"exit\",\n\t\t\t// Although the `exit` lifecycle event shares its selection object\n\t\t\t// with the `update` and `merge` lifecycle events, the object's\n\t\t\t// contents will be modified when d3.chart invokes\n\t\t\t// `d3.selection.exit`.\n\t\t\tselection: bound,\n\t\t\tmethod: bound.exit\n\t\t}\n\t];\n\n\tfor (var i = 0, l = events.length; i < l; ++i) {\n\t\teventName = events[i].name;\n\t\tselection = events[i].selection;\n\t\tmethod = events[i].method;\n\n\t\t// Some lifecycle selections modify shared state, so they must be\n\t\t// deferred until just prior to handler invocation.\n\t\tif (typeof method === \"function\") {\n\t\t\tselection = method.call(selection);\n\t\t}\n\n\t\tif (selection.empty()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Although `selection instanceof d3.selection` is more explicit,\n\t\t// it fails in IE8, so we use duck typing to maintain\n\t\t// compatability.\n\t\tassert(selection &&\n\t\t\tselection.call === d3.selection.prototype.call,\n\t\t\t\"Invalid selection defined for '\" + eventName +\n\t\t\t\"' lifecycle event.\");\n\n\t\thandlers = this._handlers[eventName];\n\n\t\tif (handlers) {\n\t\t\tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t\t\t\t// Attach a reference to the parent chart so the selection\"s\n\t\t\t\t// `chart` method will function correctly.\n\t\t\t\tselection._chart = handlers[idx].chart || this._base._chart;\n\t\t\t\tselection.call(handlers[idx].callback);\n\t\t\t}\n\t\t}\n\n\t\thandlers = this._handlers[eventName + \":transition\"];\n\n\t\tif (handlers && handlers.length) {\n\t\t\tselection = selection.transition();\n\t\t\tfor (idx = 0, len = handlers.length; idx < len; ++idx) {\n\t\t\t\tselection._chart = handlers[idx].chart || this._base._chart;\n\t\t\t\tselection.call(handlers[idx].callback);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = Layer;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./layer.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}